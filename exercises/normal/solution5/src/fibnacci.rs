pub fn odd_fibnacci_sum(threshold: u32) -> u32 {
    // TODO: 这里写逻辑
    // todo!()

    // 存储奇数斐波那契数列的和
    let mut sum =0;
    // 斐波那契数列 第 1、2 个数
    let mut a = 0;
    let mut b = 1;

    // 循环生成，直到 b 超过 threshold
    while b <= threshold{
        // 如果 b 是奇数，加到 sum 中
        if b % 2 != 0{
            sum += b;
        }
        // 计算下一个斐波那契数
        // 斐波那契数列的规则是：从第三项开始，每一项都等于前两项之和。
        // 这里我们已知当前的两个连续的斐波那契数 a 和 b，通过相加得到下一个斐波那契数。
        // 例如，假设当前 a = 1，b = 2，那么下一个斐波那契数就是 1 + 2 = 3。
        let temp = a + b;

        // 更新 a 为当前的 b
        // 因为我们要不断向后生成斐波那契数列，所以需要将 a 的值更新为当前的 b 的值。
        // 这样在下一次循环中，a 就代表了数列中的前一个数。
        // 继续上面的例子，原本 a = 1，b = 2，现在我们将 a 更新为 2，为下一次计算做准备。
        a = b;

        // 更新 b 为下一个斐波那契数
        // 把之前计算得到的下一个斐波那契数 temp 赋值给 b。
        // 这样 b 就成为了新的当前斐波那契数，用于下一次循环的判断和计算。
        // 接着上面的例子，temp = 3，现在把 b 更新为 3，此时 a = 2，b = 3，下一次循环就可以继续生成新的斐波那契数。
        b = temp;
    }
    sum
}
